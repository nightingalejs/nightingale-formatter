{"version":3,"sources":["../src/formatObject.js"],"names":["tryStringify","arg","JSON","stringify","_","internalFormatValue","value","styleFn","styles","padding","depth","maxDepth","objects","typeofValue","stringValue","undefined","toString","constructor","Object","internalFormatObject","Array","isArray","internalFormatArray","Error","stack","startsWith","message","formattedValue","separator","internalFormatIterator","values","objectStyles","prefix","suffix","prefixSuffixSpace","breakLine","formattedSeparator","valuesMaxIndex","length","map","index","key","formattedKey","indexOf","replace","v","fv","join","object","has","keys","add","result","delete","array","formatObject","Set"],"mappings":"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","file":"formatObject.js","sourcesContent":["/* eslint-disable no-use-before-define, max-lines */\n\nfunction tryStringify(arg) {\n  try {\n    return JSON.stringify(arg);\n  } catch (_) {\n    return '[Circular]';\n  }\n}\n\nfunction internalFormatValue(value, styleFn, styles, { padding, depth, maxDepth, objects }) {\n  const typeofValue = typeof value;\n\n  if (!styles) {\n    if (value == null) {\n      styles = ['cyan'];\n    } else {\n      switch (typeofValue) {\n        case 'boolean':\n          styles = ['green'];\n          break;\n        case 'number':\n          styles = ['yellow'];\n          break;\n        case 'string':\n          styles = ['orange'];\n          break;\n        case 'date':\n          styles = ['magenta'];\n          break;\n      }\n    }\n  }\n\n  let stringValue;\n  if (value === null) {\n    stringValue = 'null';\n  } else if (value === undefined) {\n    stringValue = 'undefined';\n  } else if (typeofValue === 'boolean') {\n    stringValue = value.toString();\n  } else if (value.constructor === Object) {\n    if (depth >= maxDepth) {\n      stringValue = '{object...}';\n    } else {\n      return internalFormatObject(\n        value,\n        styleFn,\n        undefined,\n        { padding, depth: depth + 1, maxDepth, objects },\n      );\n    }\n  } else if (Array.isArray(value)) {\n    if (depth >= maxDepth) {\n      stringValue = '[array...]';\n    } else {\n      return internalFormatArray(value, styleFn, { padding, depth: depth + 1, maxDepth, objects });\n    }\n  } else if (value instanceof Error) {\n    const stack = value.stack;\n    stringValue = stack.startsWith(value.message) ? stack : `${value.message}\\n${stack}`;\n  } else {\n    stringValue = tryStringify(value);\n  }\n\n  const formattedValue = styleFn(styles, stringValue);\n\n  return {\n    stringValue,\n    formattedValue,\n  };\n}\n\nconst separator = ',';\n\nconst internalFormatIterator = (\n  values,\n  styleFn,\n  objectStyles,\n  { padding, depth, maxDepth, objects },\n  { prefix, suffix, prefixSuffixSpace = ' ' },\n) => {\n  let breakLine = false;\n  const formattedSeparator = () => styleFn(['gray'], separator);\n\n  const valuesMaxIndex = values.length - 1;\n  values = values.map(({ key, value }, index) => {\n    let nextDepth = depth + 1;\n\n    // key must be formatted before value (browser-formatter needs order)\n    const formattedKey = key ? `${styleFn(['gray-light', 'bold'], `${key}:`)} ` : '';\n\n    let { stringValue, formattedValue } = internalFormatValue(\n      value,\n      styleFn,\n      key && objectStyles && objectStyles[key],\n      { padding, depth: nextDepth, maxDepth, objects },\n    );\n\n    if (stringValue && (stringValue.length > 80 || stringValue.indexOf('\\n') !== -1)) {\n      breakLine = true;\n      stringValue = stringValue.replace(/\\n/g, `\\n${padding}`);\n      formattedValue = formattedValue.replace(/\\n/g, `\\n${padding}`);\n    }\n\n    return {\n      stringValue: stringValue + (index === valuesMaxIndex ? '' : separator),\n      // eslint-disable-next-line no-useless-concat\n      formattedValue: formattedKey + formattedValue + (index === valuesMaxIndex ? '' : formattedSeparator()),\n      // note: we need to format the separator for each values for browser-formatter\n    };\n  });\n\n  return {\n    stringValue: prefix + values\n      .map(breakLine ? v => `\\n${padding}${v.stringValue}` : fv => fv.stringValue)\n      .join(breakLine ? '\\n' : ' ')\n      + suffix,\n    // eslint-disable-next-line prefer-template\n    formattedValue: `${prefix}${breakLine ? '' : prefixSuffixSpace}`\n      + values.map(breakLine ? v => `\\n${padding}${v.formattedValue}` : v => v.formattedValue)\n        .join(breakLine ? '' : ' ')\n      + `${breakLine ? ',\\n' : prefixSuffixSpace}${suffix}`,\n  };\n};\n\nfunction internalFormatObject(\n  object,\n  styleFn,\n  objectStyles,\n  { padding, depth, maxDepth, objects },\n) {\n  if (objects.has(object)) {\n    return { stringValue: '{Circular object}', formattedValue: '{Circular object}' };\n  }\n\n  const keys = Object.keys(object);\n  if (keys.length === 0) {\n    return {\n      stringValue: '{}',\n      formattedValue: '{}',\n    };\n  }\n\n  objects.add(object);\n\n  const result = internalFormatIterator(\n        keys.map(key => ({ key, value: object[key] })),\n        styleFn,\n        objectStyles,\n        { padding, depth, maxDepth, objects },\n        { prefix: '{', suffix: '}' },\n    );\n\n  objects.delete(object);\n\n  return result;\n}\n\n\nfunction internalFormatArray(array, styleFn, { padding, depth, maxDepth, objects }) {\n  if (objects.has(array)) {\n    return { stringValue: '{Circular array}', formattedValue: '{Circular array}' };\n  }\n\n  if (array.length === 0) {\n    return {\n      stringValue: '[]',\n      formattedValue: '[]',\n    };\n  }\n\n  objects.add(array);\n\n  const result = internalFormatIterator(\n    array.map(value => ({ key: undefined, value })),\n    styleFn,\n    undefined,\n    { padding, depth, maxDepth, objects },\n    { prefix: '[', suffix: ']', prefixSuffixSpace: '' },\n  );\n\n  objects.delete(array);\n\n  return result;\n}\n\nexport default function formatObject(object, styleFn, objectStyles, {\n    padding = '  ',\n    maxDepth = 10,\n} = {}) {\n  const { formattedValue: result } = internalFormatObject(\n    object,\n    styleFn,\n    objectStyles,\n    { padding, maxDepth, depth: 0, objects: new Set() },\n  );\n\n  if (result === '{}') {\n    return '';\n  }\n\n  return result;\n}\n"]}